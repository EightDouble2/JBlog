---
title: "对象的实例化内存布局与访问定位"
date: 2020-09-10T22:01:17+08:00
draft: false
tags: [ "JVM" ]
categories: [ "技术文档" ]
---
# 对象的实例化内存布局与访问定位

## 对象的实例化

![img](/img/对象的实例化内存布局与访问定位001.png)

#### 创建对象的步骤

- 加载类元信息，判断对象对应的类是否加载、链接、初始化
  - 虚拟机遇到一条 new 指令，首先去检査这个指令的参数能否在 Metaspace 的常量池中定位到一个类的符号引用，并且检査这个符号引用代表的类是否已经被加载、解析和初始化。（即判断类元信息是否存在）。如果没有，那么在双亲委派模式下，使用当前类加载器以 ClassLoader + 包名 + 类名为 Key 进行查找对应的， .class文件。如果没有找到文件，则抛出 `ClassNotFoundException` 异常，如果找到，则进行类加载，并生成对应的 Class 类对象
- 为对象分配内存
  - 首先计算对象占用空间大小，接着在堆中划分一块内存给新对象。
  - 如果实例成员变量是引用变量，仅分配引用变量空间即可，即 4 个字节大小。
    - 如果内存规整，使用指针碰撞
      - 如果内存是规整的，那么虛拟机将采用的是指针碰撞法（ Bump The Pointer ）来为对象分配内存。意思是所有用过的内存在一边，空闲的内存在另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是 Serial、 ParNew 这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带有 compact （整理）过程的收集器时，使用指针碰撞。
  - 如果内存不规整，虚拟机需要维护一个列表，使用空闲列表分配
    - 如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表法来为对象分配内存。意思是虚拟机维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式成为“空闲列表（ Free List ）”。
  - 说明：**选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定**
- 处理并发安全问题
  - 在分配内存空间时，另外一个问题是及时保证 new 对象时候的线程安全性：创建对象是非常频繁的操作，虚拟机需要解决并发问题。虚拟机采用了两种方式解决并发问题：
    - CAS （ Compare And Swap ）失败重试、区域加锁：保证指针更新操作的原子性；
    - TLAB 把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在 Java 堆中预先分配一小块内存，称为本地线程分配缓冲区，（ TLAB ， Thread Local Allocation Buffer ）虚拟机是否使用 TLAB ，可以通过 `-XX:+/-UseTLAB` 参数来设定。
- 初始化分配到的空间
  - 内存分配结束，**虚拟机将分配到的内存空间都初始化为零值**（不包括对象头）。这一步保证了对象的实例字段在 Java 代码中可以不用赋初始值就可以直接使用，程序能访问到这些字段的数据类型所对应的零值
- 设置对象的对象头
  - 将对象的所属类（即类的元数据信息）、对象的 HashCode 和对象的 GC 信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于 JVM 实现
- 执行 `init()` 方法进行初始化
  - 在 Java 程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量
  - 因此一般来说（由字节码中是否跟随有 invokespecial 指令所决定）， new 指令之后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全创建出来。

## 对象的内存布局

![img](/img/对象的实例化内存布局与访问定位002.png)

```java
public class Customer {
    int id = 1001;
    String name;
    Account acct;

    {
        name = "匿名客户";
    }
    public Customer(){
        acct = new Account();
    }

}
class Account{

}
```

new 一个 Customer 对象时的内存布局

![img](/img/对象的实例化内存布局与访问定位003.png)

## 对象的访问定位

- JVM 如何通过栈帧中的对象引用访问到其内部的对象实例呢？

  定位，通过栈上 reference 访问

![img](/img/对象的实例化内存布局与访问定位004.png)

- 创建对象的目的是为了使用它。
- 对象访问方式主要有两种
  - 句柄访问
    - 栈的局部变量表记录了对象指针，指向堆空间的句柄池。
    - 句柄池中分别记录了到堆空间的对象实例数据的指针和到方法区的对象类型数据的指针。
    - 优点：局部变量中存储稳定的句柄地址，当对象被移动时只会改变句柄中实例数据指针即可，局部变量本身不需要修改。
  - **直接指针**（HotSpot 采用）
    - 栈的局部变量表直接记录了对象实例数据的指针。
    - 对象实例数据中记录了到方法区的对象类型数据的指针。
    - 优点：节省空间，速度快。